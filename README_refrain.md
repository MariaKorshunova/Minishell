Токен - условная логическая единица. Мы будем различать двойные и одинарные кавычки, и это все будет разными токенами
envp_list содержит самую новую информацию о переменной окружения

односвязный список:
key1	key2
	->
val1	val2

1. Typedef

Определим указатели на функции builin'ов, чобы потом их можно было хранить в массиве, который будет состоять из этих указателей

typedef int (&t_builtin_ptr)(t_list *, t_info *) 

&t_builtin_ptr - указатель на функцию builtin'a, сможем обратиться к нему и передать 2 параметра: info - общая структура, которую определим чуть позже и односвязный список аргументов для данного builtin'a 
Внутри односвязаного списка будет лежать пара (элемент не просто будет указывать на что-то, а будет указывать на пару ключ-значение key-val)
Односвязный список будет состоять из пар (один элемент - это пара). Внутри связного списка будет 2 void *: один на ключ, другой на значение

key - void *, можем положить что угодно

t_info 
Внутри t_info будет массив указателей на функции builtin'a, чтобы их потом вызывать
{
t_builin_ptr builtins[7] (здесь не ставится указатель, т.к. в прототипе изначально прописан указатель)

char    reserved_words[7] (названия наших builtin'ов, их 7 по сабджекту). Массив, элемент которого строка, и строка, например, env. Т.е. мы будем сравнивать первый аргумент, который мы получили в команде, когда мы будем искать, какой builtin исполнить, мы будем сравнивать со словами в массиве, совпадает ли на 100% с тем, что нам подали. 

char **envp - массив переменное окружение, который мы будем постоянно изменять

t_list	envp_list  - односвязный список, который будет в себе содержать пару key/val, будет отображать текущее состояние переменной окружение. Если операции над листом не были произведены, не нужно пересобирать массив

char	 envp_f; флаг, 1 - если нужно пересобрать перебенную, если 0 - можно передать указатель на массив

char	exit_t	флаг выхода; в builtin'e, когда вызываем exit, мы должны поставить exit_t в 0, т.е. не нужно больше выполнять зацикливание (чтение команды, обработка, исполнение). После исполнения exit_t будет в нуле и мы выйдем из минишелла, освободив при этом ресурсы

int	status отвечает за исполнение команды. все наши команды ьудут исполняться в подпроцессах, за исключением builtin'ов. След-но, сигналы будут обрабатываться иным способом, т.е. мы не будем отдавать глобальную переменную в handler сигналов, а мы будем смотреть статус выхода процесса. Не нужно делать переменную status глобальной

можно объявить здесь еще 2 листа (либо дописать в мейнике): лист токенов и лист групп либо команд
можно пропустить шаг группировки на логические группы и сразу группировать на пайпы. Смотрим, есть ли пайп в команде, то нужно его проверить на синтаксис пайплайна после группировки
}

WIFSIGNALED(sig) удобный способ узнать, завершился ли процесс сигналом

waitpid(pid, &sig, 0) &sig - основная информация, а именно статус выхода

В мейне все просто: сначала инициализируемся
Этапы мейна:
1. инициализация init
определение всех наших указателей, всех наших слов
первичная сборвка envp и первичное заполнение envp_list
2. цикл пока не нужно выходить, мы обрабатываем все, что внутри цикла
while (!exit_t)
Внутри цикла: 
2.1. чтение строки (помогает readline)
делаем readline, если считали не пустую строку (вернулся не нулевой указатель), мы добавляем его в историю и возвращаем просто как строку
ft_readline - считать строку (просто readline не обновит историю)
//s = realine(p)

char *ft_readline (char *) здесь указать prompt: bash, minishell; также вернуть указатель на строку (его нужно будет освободить)
внутри ft_realine вызов библиотечной readline (что-то вернет, если строка не пустая, нужно добавить в историю, даже абракадабру)

if(s)
	add_history(s)
	return s

2.2. lexer 
обработка строки
сначала нужно разбить на токены в лексере

2.3. parser

2.4. executor исполнение 

3. destruct освободить все ресурсы

2. Структуры
3. Контейнеры
4. лексер, парсер, исполнитель

В лексере будем определять типы токенов, и эти типы токенов будут превращаться в числа (например, 1 - разделитель)& Тогда данный элемент имеет тип разделитель и значение val
Все, что в двойных кавычках, будет считаться токеном

WTERMSIG - узнать номер сигнала

5. сигналы и 
6. обработка внутренних команд (builtin)
